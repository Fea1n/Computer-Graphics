![](D:\Pictures\TWITTER\FHCQsKMaIAAa_Dy.jpg)

## #0 Base

### Vulkan

1. stype在 vk*createinf·o结构 中的作用 为了使用pNext的功能
2. vkresult 用于返回值
3. WSI window system integration 窗口系统集成



### C++ 

#### 标准方法

1. 普通成员函数 编译时，会隐式增加一个形参this
2. 不常用namespace ,使用namespace 会导致命名冲突，版本升级会出问题
3. strcmp 比较字符串，三种结果
4. 注意！ *Cpp中引用 区别 指针*  ！
5. 静态类函数
6. 注意 int* p ,q表示 int *p,int q 
7. auto标明一个变量，这个变量永远不会是应用变量 auto& 有可能被编译器推导为引用变量
8. 向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。
9. static_cast 一般来说，编译器隐式执行的任何类型转换都可以由static_cast显式完成。
10. C26495为所有成员添加类内初始化
11. reinterpret_cast 强制类型转化

#### C++ 17 

1. .have_value()显示是否有值
2. std:: optional 处理可能为空的数值 | nullptr 也可处理可能为空的指针
3. std::clamp限制区间的值,大于则取最大，小于取最小，区间内则原数值不变



标准文件之间调用 

extern



## #1 起步 setup



### 1.1 基本代码框架

```c++
class helloapplication{
public:
  void run(){
		initwindow();
    initvulkan();
    mainloop();
    cleanup();
  }

private:
  void initwindow(){
}
  void initvulkan(){
}
  void mainloop(){
}
  void cleanup(){
}
};

int main(){

  
}
```





### 1.2 实例

创建实例

创建实例来初始化Vulkan库，实例是应用程序和Vulkan库之间的连接，创建它涉及向驱动程序指定有关程序的一些详细信息

```cpp
 void createInstance() {
        VkApplicationInfo appInfo{};
        appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
        appInfo.pApplicationName = "Hello Triangle";
        appInfo.applicationVersion = VK_MAKE_VERSION(1, 0, 0);
        appInfo.pEngineName = "No Engine";
        appInfo.engineVersion = VK_MAKE_VERSION(1, 0, 0);
        appInfo.apiVersion = VK_API_VERSION_1_0;

        VkInstanceCreateInfo createInfo{};
        createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
        createInfo.pApplicationInfo = &appInfo;

        uint32_t glfwExtensionCount = 0;
        const char** glfwExtensions;
        glfwExtensions = glfwGetRequiredInstanceExtensions(&glfwExtensionCount);

        createInfo.enabledExtensionCount = glfwExtensionCount;
        createInfo.ppEnabledExtensionNames = glfwExtensions;

        createInfo.enabledLayerCount = 0;

        if (vkCreateInstance(&createInfo, nullptr, &instance) != VK_SUCCESS) {
            throw std::runtime_error("failed to create instance!");
        }
    }
```

遇到VK_ERROR_INCOMPATIBLE_DRIVER



检查扩展支持

清理干净

实例应该在程序退出之前被销毁

### 1.3 验证层

常见操作

> - 根据规范检查参数值以检测误用
> - 跟踪对象的创建和销毁以查找资源泄漏
> - 通过跟踪调用源自的线程来检查线程安全
> - 将每个调用及其参数记录到标准输出
> - 跟踪 Vulkan 调用分析和重播
>



vklayerpropertities 

```cpp
// Provided by VK_VERSION_1_0
typedef struct VkLayerProperties {
    char        layerName[VK_MAX_EXTENSION_NAME_SIZE];
    uint32_t    specVersion;
    uint32_t    implementationVersion;
    char        description[VK_MAX_DESCRIPTION_SIZE];
} VkLayerProperties;
```



vkextensionproperties 

```cpp
VkResult vkVtreateInstance{
	const VkInstanceCreateInfo* pCreateInfo;
	const VkAllocationCallbacks* pAllocator;
	
}
```



#### 使用验证层

所有验证标准捆绑到SDK中的一个层中，VK_LAYER_KHRONOS_validation



check validationlayersupport



创建实例，绑定验证扩展，通过pNext进一步扩展





#### 消息回调

vk_ext_debug_utils 可以避免拼写错误



get requiredextentions 







#### 调试实例的创建和销毁



#### 测试



#### 配置



### 1.4 物理设备和队列族

#### 选择物理设备



#### 基本设备适用性检查



#### 队列族

每个操作都需要将命令上传到队列

队列族 的结构特征

通用检查







### 1.5 逻辑设备和队列







## #2 演示 presentation

### 2.1 窗口表面 window surface

#### 2.1.1 窗口表面创建

Vksurface surface 

#### 2.1.2 查询演示支持

在同一队列族中创建绘图和演示的的两个队列

可以添加逻辑以明确首选支持同一队列中的绘图和呈现的物理设备，以提高性能。

```cpp
typedef enum VkQueueFlagBits {
    VK_QUEUE_GRAPHICS_BIT = 0x00000001,
    VK_QUEUE_COMPUTE_BIT = 0x00000002,
    VK_QUEUE_TRANSFER_BIT = 0x00000004,
    VK_QUEUE_SPARSE_BINDING_BIT = 0x00000008,
  // Provided by VK_VERSION_1_1
    VK_QUEUE_PROTECTED_BIT = 0x00000010,
  // Provided by VK_KHR_video_decode_queue
    VK_QUEUE_VIDEO_DECODE_BIT_KHR = 0x00000020,
#ifdef VK_ENABLE_BETA_EXTENSIONS
  // Provided by VK_KHR_video_encode_queue
    VK_QUEUE_VIDEO_ENCODE_BIT_KHR = 0x00000040,
#endif
  // Provided by VK_NV_optical_flow
    VK_QUEUE_OPTICAL_FLOW_BIT_NV = 0x00000100,
} VkQueueFlagBits;
```

- `VK_QUEUE_GRAPHICS_BIT`指定此队列系列中的队列支持图形操作。
- `VK_QUEUE_COMPUTE_BIT`指定此队列系列中的队列支持计算操作。
- `VK_QUEUE_TRANSFER_BIT`指定此队列系列中的队列支持传输操作。
- `VK_QUEUE_SPARSE_BINDING_BIT`指定此队列系列中的队列支持稀疏内存管理操作（请参阅 [稀疏资源](https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#sparsememory)）。如果启用了任何稀疏资源功能，则至少有一个队列系列**必须**支持此位。
- `VK_QUEUE_VIDEO_DECODE_BIT_KHR`指定此队列系列中的队列支持[视频解码操作](https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations)。
- `VK_QUEUE_VIDEO_ENCODE_BIT_KHR`指定此队列系列中的队列支持[视频编码操作](https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations)。
- `VK_QUEUE_OPTICAL_FLOW_BIT_NV`指定此队列族中的队列支持光流操作。
- `VK_QUEUE_PROTECTED_BIT`指定此队列系列中的队列支持该`VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT`位。（请参阅[受保护的内存](https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#memory-protected-memory)）。如果物理设备支持该[`protectedMemory`](https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#features-protectedMemory)功能，则其队列系列中至少有一个 **必须**支持该位。

#### 2.1.3 创建演示队列

修改逻辑设备的创建过程

### 2.2 交换链 swap chain

即为 默认帧缓冲区，本质为一个等待呈现到屏幕上的图像队列

#### 2.2.1 [检查交换链支持](https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Swap_chain#page_Checking-for-swap-chain-support)



#### 2.2.2 [启用设备扩展](https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Swap_chain#page_Enabling-device-extensions)



#### 2.2.3 [查询交换链支持详情](https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Swap_chain#page_Querying-details-of-swap-chain-support)

三种属性

基本表面功能

表面格式

可用的演示模式



创建一个新函数 来填充query

swapchain support details

#### 2.2.4 [为交换链选择正确的设置](https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Swap_chain#page_Choosing-the-right-settings-for-the-swap-chain)



##### 2.2.4.1 [表面格式](https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Swap_chain#page_Surface-format)

颜色通道和色彩深度，颜色空间类型

##### 2.2.4.2 [演示模式](https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Swap_chain#page_Presentation-mode)



##### 2.2.4.3 [交换范围](https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Swap_chain#page_Swap-extent)

使用clamp函数为最小和最大交换范围限制数值。

#### 2.2.5 [创建交换链](https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Swap_chain#page_Creating-the-swap-chain)



#### 2.2.6 [检索交换链图像](https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Swap_chain#page_Retrieving-the-swap-chain-images)





### 2.3 图片浏览 image views

渲染管道中使用VKImage包括交换链中的，需要创建VkImageView对象

subresourcerange 描述图像的用途是什么以及应该访问图像的哪一部分



## #3 图形管线基础 graphics pipeline basics

### 3.1 介绍

![img](https://vulkan-tutorial.com/images/vulkan_simplified_pipeline.svg)

*输入汇编程序*从您指定的缓冲区收集原始顶点数据，并且还可以使用索引缓冲区来重复某些元素，而不必复制顶点数据本身。

*顶点着色器*为每个顶点运行，并且通常应用变换将顶点位置从模型空间转换到屏幕空间。它还将每个顶点的数据传递到管道中。

*曲面细分着色器*允许您根据特定规则细分几何体以提高网格质量。这通常用于使砖墙和楼梯等表面在附近时看起来不那么平坦。

*几何着色器*在每个图元（三角形、线、点）上运行，并且可以丢弃它或输出比进来的图元更多的图元。这类似于曲面细分着色器，但更加灵活。但是，它在今天的应用程序中使用不多，因为除了 Intel 的集成 GPU 之外，大多数显卡的性能都不是很好。

*光栅化*阶段将图元离散化为*片段*。这些是它们填充在帧缓冲区上的像素元素。落在屏幕外的任何片段都将被丢弃，顶点着色器输出的属性将插值到片段中，如图所示。通常由于深度测试，落后于其他原始片段的片段也会在这里被丢弃。

为每个幸存的片段调用*片段着色器，并确定将片段写入哪些帧缓冲区以及使用哪些颜色和深度值。*它可以使用来自顶点着色器的插值数据来执行此操作，其中可以包括纹理坐标和照明法线等内容。

*颜色混合*阶段应用操作来混合映射到帧缓冲区中相同像素的不同片段。片段可以简单地相互覆盖、相加或根据透明度混合。

### 3.2 着色器模块 shader modules

vulkan着色器必须用SPIR-V字节格式指定



#### 3.2.1 [顶点着色器](https://vulkan-tutorial.com/en/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules#page_Vertex-shader)

传入每个顶点的属性，世界位置，颜色，法线，纹理坐标

#### 3.2.2 [片段着色器](https://vulkan-tutorial.com/en/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules#page_Fragment-shader)

为帧缓冲器提供颜色和深度信息

#### 3.2.3 [逐顶点颜色](https://vulkan-tutorial.com/en/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules#page_Per-vertex-colors)



#### 3.2.4 [编译着色器](https://vulkan-tutorial.com/en/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules#page_Compiling-the-shaders)



#### 3.2.5 [加载着色器](https://vulkan-tutorial.com/en/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules#page_Loading-a-shader)



#### 3.2.6 [创建着色器模块](https://vulkan-tutorial.com/en/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules#page_Creating-shader-modules)



#### 3.2.7 [着色器阶段创建](https://vulkan-tutorial.com/en/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules#page_Shader-stage-creation)

最终为 着色器阶段 服务

### 3.3 固定功能 fixed functions

#### 3.3.1[动态状态](https://vulkan-tutorial.com/en/Drawing_a_triangle/Graphics_pipeline_basics/Fixed_functions#page_Dynamic-state)



#### 3.3.2[顶点输入](https://vulkan-tutorial.com/en/Drawing_a_triangle/Graphics_pipeline_basics/Fixed_functions#page_Vertex-input)



#### 3.3.3[输入组件](https://vulkan-tutorial.com/en/Drawing_a_triangle/Graphics_pipeline_basics/Fixed_functions#page_Input-assembly)



#### 3.3.4[视口和剪刀](https://vulkan-tutorial.com/en/Drawing_a_triangle/Graphics_pipeline_basics/Fixed_functions#page_Viewports-and-scissors)



#### 3.3.5[光栅器](https://vulkan-tutorial.com/en/Drawing_a_triangle/Graphics_pipeline_basics/Fixed_functions#page_Rasterizer)



#### 3.3.6[多重采样](https://vulkan-tutorial.com/en/Drawing_a_triangle/Graphics_pipeline_basics/Fixed_functions#page_Multisampling)



#### 3.3.7[深度和模板测试](https://vulkan-tutorial.com/en/Drawing_a_triangle/Graphics_pipeline_basics/Fixed_functions#page_Depth-and-stencil-testing)



#### 3.3.8[颜色混合](https://vulkan-tutorial.com/en/Drawing_a_triangle/Graphics_pipeline_basics/Fixed_functions#page_Color-blending)



#### 3.3.9[管道布局](https://vulkan-tutorial.com/en/Drawing_a_triangle/Graphics_pipeline_basics/Fixed_functions#page_Pipeline-layout)



#### 3.3.10[结论](https://vulkan-tutorial.com/en/Drawing_a_triangle/Graphics_pipeline_basics/Fixed_functions#page_Conclusion)



### 3.4 渲染通道 render passes

#### 3.4.1[设置](https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Render_passes#page_Setup)



#### 3.4.2[附件说明](https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Render_passes#page_Attachment-description)



#### 3.4.3[子通道和附件参考](https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Render_passes#page_Subpasses-and-attachment-references)



#### 3.4.4[渲染通道](https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Render_passes#page_Render-pass)



一个render pass 会执行pipeline 多次，subpass 

attchment 包含 深度

### 3.5 总结

着色器阶段

固定函数

管道布局

渲染通道





## #4 绘制 drawing 

### 4.1 帧缓冲



### 4.2 指令缓冲



### 4.3 渲染和演示 rendering and presentation

drawframe



等待上一帧的完成

从交换链获取一张图像

对帧缓冲附着指令缓冲中的渲染指令

提交记录的命令缓冲区

返回渲染后的图像到交换链进行呈现操作









栅栏同步cpu和gpu，信号量同步同一指令队列



几处同步问题

注意信号量的同步问题

渲染流程和image获取的同步问题















### 4.4 飞行中的帧 frames in flight



## #5 交换链重建 swap chain recreation













